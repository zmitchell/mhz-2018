////////////////////////////////////////////////////////////////////////////////
//
// Program Settings
//
////////////////////////////////////////////////////////////////////////////////

UseVBX = 0  // Set to 0 to omit VBX controls, 1 to use them
Debug = 0  // Debug level (0 - none, 1-low, 2 -deep)
StatLine = 1  // status line length

Log = 10
Log$ = "pprobe.log"
IF Log>0;
+   openp Log$ output #9;
+   print #9,"\n******************************************************"

LockSlow = 0  // Get Q,x1,x2,x3 from LockIn in one command (0) or separately (1)

StepperPort = 8  // Com Port number to which the stepper controller is connected
LockPort = 9  // Com Port number to which LockIn is connected

StepperWait = 0.3  //switch to low power in 0.3 seconds after moving is over
StepperDiv = 4  // stepper internal speed divider
StepperLow = 600  // set start speed in Hz
StepperHigh = 4400  // Set max stepper speed in Hz (assume half step operation
StepperAccel = 20  // Stepper acceleration (8 stalls)
StepperDecel = 10  // Stepper deceleration
StepperStep = 0.1/300  // step in picoseconds per step of the delay line (half step, 0.05 micron)
// I use opencom as #3
LockSensitivity = 1e4  // Set sensitivity of lockin in micro-dA units per V
LockNeedleTau = 250

////////////////////////////////////////////////////////////////////////////////
//
// Load Saved Settings
//
////////////////////////////////////////////////////////////////////////////////

GOSUB LoadStepperPars  // overload defaults with saved ones (if exist) including port numbers !!!
GOSUB SelectComPort

////////////////////////////////////////////////////////////////////////////////
//
// @unsure Set default scan parameters?
//
////////////////////////////////////////////////////////////////////////////////

ScanTo = 100
ScanFs = 7  // number of points where step can change
dim ScanF(ScanFs)
dim ScanS(ScanFs)
dim ScanT(ScanFs)
FOR i = 1,ScanFs
    ScanF(i)=0
    ScanS(i)=0
    ScanT(i)=0
NEXT
DAdiv = 1
InstrDiv = 1
UseTemplate = 0
xtemplate = 1
ScanSpecDA = 1
ScanSpecInstr = 0
ScanSpecX1 = 0
ScanSpecX2 = 0
SpecNorm = 0
ScanComment$ = ""
AccuBack = 3  // collect background 3 seconds (set to 0 not to compensate!)
//print "\nload"
GOSUB LoadScanPars  // overload scan pars if exist
//print "\n length = ",ScanComment$(0),"\n"

////////////////////////////////////////////////////////////////////////////////
//
// Connect to Equipment
//
////////////////////////////////////////////////////////////////////////////////

//print " \n"  // funny but needed just like that to print in normal font size!
TEXT SET SIZE 10  // in some Windows systems default is 16!
//t = clock()+100
//wt:if clock()<t;GOTO wt
PRINT "Connecting: Stepper driver on COM port #", StepperPort, "..."
GOSUB StepperInit
PRINT "Connecting: LIA on COM port #",LockPort,"..."
GOSUB LockInit
GOSUB LockGetAll
GOSUB LockFlush
//if Log>0;openp Log$ output #9;PRINT #9,"\n******************************************************"
send$ = "\n\n"
GOSUB LockSend
GOSUB LockFlush

//agaga:
//tt = clock();GOSUB LockGetSignal;tt = clock()-tt
//print "\n",tt
//GOTO agaga

////////////////////////////////////////////////////////////////////////////////
//
// Default values FOR control window widgets
//
////////////////////////////////////////////////////////////////////////////////

LockScale=-1
LockCurScale=-1
LockScaleMult = 1
LockSignalUnit$ = "uV"
LockSignal$ = "Lock Signal"
ExitIt = 0
LockCurSignal = 0
SensitivityMinus = 0
SensitivityPlus = 0
NeedleValue = 0

DelayCurPos = 0
DelayCurPos$ = "0"
SetOriginButton = 0
GoButton = 0
Moving1 = 1
Button10p = 0
Button10m = 0
Button100p = 0
Button100m = 0
Button1000p = 0
Button1000m = 0
ButtonStop = 0
ButtonScan = 0
ButtonMotor = 0
Shutter = 0
ShutterButton = 0
ShutterButton$ = "Shutter Closed"
ButtonExit = 0
IF debug>1;
+   PRINT "[DelayGet]"
GOSUB DelayGet
IF debug>1;
+   PRINT "[gotit]"
DelayNewPos$ = DelayPos
TTYlockin = 0
Stat$ = ""

////////////////////////////////////////////////////////////////////////////////
//
// Control window layout
//
////////////////////////////////////////////////////////////////////////////////

y = 5
h = 29
CONTROL OPEN 0,0,0,0,"Control Pump-Probe",exitIt

CONTROL ADD BUTTON 10,y,40,h,"<",SensitivityMinus
CONTROL ADD TEXT S = 1,55,y+6,35,h-6,"SENS"
CONTROL ADD BUTTON 95,y,40,h,">",SensitivityPlus
CONTROL ADD TEXT S = 2,150,y+6,49,h-6,"Signal: "
CONTROL ADD TEXT S = 2,200,y+6,60,h-6,LockSignal$
CONTROL ADD TEXT 262,y+6,30,h-6,LockSignalUnit$
CONTROL ADD BUTTON 288,y,15,h,"D",TTYlockin
y = y+h+4

//CONTROL ADD GROUPBOX 3,y,304,h*3+15,Dummy$,db

y = y+7
CONTROL ADD TEXT S = 2,5,y+6,148,h-6,"Delay line position:"
CONTROL ADD TEXT S = 2,155,y+6,60,h-6,DelayCurPos$
CONTROL ADD TEXT 235,y+6,20,h-6,"ps"
CONTROL ADD BUTTON 260,y,40,h,"SET",SetOriginButton

y = y+h
CONTROL ADD TEXT S = 2,5,y+6,148,h-6,"New position:"
CONTROL ADD EDIT S = 2,160,y,65,h,DelayNewPos$,Edit
CONTROL ADD TEXT 235,y+6,20,h-6,"ps"
CONTROL ADD BUTTON 260,y,40,h,"GO",GoButton

y = y+h+2
CONTROL ADD BUTTON 35,y,30,h,"<<<",Button1000m
CONTROL ADD BUTTON 70,y,30,h,"<<",Button100m
CONTROL ADD BUTTON 105,y,30,h,"<",Button10m
CONTROL ADD BUTTON 140,y,55,h,"STOP",ButtonStop
CONTROL ADD BUTTON 200,y,30,h,">",Button10p
CONTROL ADD BUTTON 235,y,30,h,">>",Button100p
CONTROL ADD BUTTON 270,y,30,h,">>>",Button1000p

y = y+h+8
CONTROL ADD BUTTON 5,y,60,h,"Scan",ButtonScan
CONTROL ADD BUTTON 70,y,130,h,ShutterButton$,ShutterButton
CONTROL ADD BUTTON 205,y,50,h,"Setup",ButtonMotor
CONTROL ADD BUTTON 260,y,40,h,"Exit",ButtonExit

y = y+h+3
IF StatLine>0;
+   CONTROL ADD TEXT x,y,300,h-6,Stat$
CONTROL SHOW

////////////////////////////////////////////////////////////////////////////////
//
// Main loop update settings
//
////////////////////////////////////////////////////////////////////////////////

dtc = 200  // update all everything 200 ms
dtn = 50  // update needle every 50 ms
dts = 500  // update signal text only every 500 ms
dtf = 5000  // Flush LockIn every 5 seconds
tc = clock()
tn = tc
ts = tc
tf = tc+dtf

////////////////////////////////////////////////////////////////////////////////
//
// Main loop
//
////////////////////////////////////////////////////////////////////////////////

loop:
IF TTYlockin>0;
+   GOSUB TTYlockin;
+   TTYlockin = 0
IF ButtonExit>0;
+   GOSUB LockFlush;
+   GOSUB StepperFlush;
+   close #3;
+   close #4;
+   close #9;
+   stop  // use for logging
IF SensitivityMinus>0;
+   GOSUB LockSensDown;
+   SensitivityMinus = 0
IF SensitivityPlus>0;
+   GOSUB LockSensUp;
+   SensitivityPlus = 0
IF ButtonStop>0;
+   GOSUB StepperStop;
+   ButtonStop = 0
IF Button1000m>0;
+   DelayNewPos$ = DelayNewPos$ - Button1000m;
+   Button1000m = 0;
+   GoButton = 1;
IF Button100m>0;
+   DelayNewPos$ = DelayNewPos$ - Button100m * 0.1;
+   Button100m = 0;
+   GoButton = 1;
IF Button10m>0;
+   DelayNewPos$ = DelayNewPos$ - Button10m * 0.01;
+   Button10m = 0;
+   GoButton = 1;
IF Button10p>0;
+   DelayNewPos$ = DelayNewPos$ + Button10p * 0.01;
+   Button10p = 0;
+   GoButton = 1;
IF Button100p>0;
+   DelayNewPos$ = DelayNewPos$ + Button100p * 0.1;
+   Button100p = 0;
+   GoButton = 1;
IF Button1000p>0;
+   DelayNewPos$ = DelayNewPos$ + Button1000p;
+   Button1000p = 0;
+   GoButton = 1;
IF GoButton>0;
+   DelayNewPos = DelayNewPos$;
+   GOSUB DelayGo;
+   GoButton = 0;
+   Moving1 = 1
IF ShutterButton>0;
+   ShutterButton = 0;
+   Shutter = abs(Shutter - 1);
+   GOSUB ShutterOpen;
+   ShutterButton$ = "Shutter Closed";
+   IF Shutter = 1;
+       ShutterButton$ = "Shutter Open"
IF ButtonScan>0;
+   ButtonStop = 0;
+   ButtonScan = 0;
+   GOSUB Scan;
+   ButtonStop = 0;
+   ButtonScan = 0
IF ButtonMotor>0;
+   GOSUB StepperSetup;
+   ButtonMotor = 0
IF SetOriginButton>0;
+   SetOriginButton = 0;
+   INPUTBOX "Set origin","Let this Delay position be (ps) = ",t$,8,ret;
+   IF ret = 1;
+       DelayOrigin = -t$;
+       IF DelayOrigin>-1000;
+           IF DelayOrigin<20000;
+               GOSUB DelaySetOrigin;
+               Moving1 = 1

IF clock()>tn;
+   tn = clock() + dtn;
+   GOSUB UpdateNeedle
IF clock()>ts;
+   ts = clock() + dts;
+   LockSignal$ = LockCurSignal * LockSignalMult
IF clock()>tf;
+   send$ = "\n\n";
+   GOSUB LockSend;
+   GOSUB LockFlush;
+   GOSUB LockFlush;
+   tf = clock() + dtf
IF clock()<tc;
+   GOTO loop
GOSUB LockGetScale
IF LockCurScale<>LockScale;
+   GOSUB UpdateScale;
+   LockCurScale = LockScale
IF Moving1>0;
+   GOSUB StepperMoving
IF Moving1>0;
+   GOSUB DelayGet;
+   IF DelayPos<>DelayCurPos;
+       DelayCurPos = DelayPos;
+       DelayCurPos$ = -DelayPos
Moving1 = Moving

GOTO loop

////////////////////////////////////////////////////////////////////////////////
//
// Control window subroutines
//
////////////////////////////////////////////////////////////////////////////////

// Enable/disable controls while scanning
EnableControl:
e = EnableControl
CONTROL ENABLE SensitivityMinus,e
CONTROL ENABLE SensitivityPlus,e
CONTROL ENABLE SetOriginButton,e
CONTROL ENABLE Edit,e
CONTROL ENABLE GoButton,e
CONTROL ENABLE Button1000m,e
CONTROL ENABLE Button100m,e
CONTROL ENABLE Button10m,e
CONTROL ENABLE Button10p,e
CONTROL ENABLE Button100p,e
CONTROL ENABLE Button1000p,e
CONTROL ENABLE ButtonScan,e
CONTROL ENABLE ShutterButton,e
CONTROL ENABLE ButtonMotor,e
CONTROL ENABLE ButtonExit,e
CONTROL ENABLE TTYLockIn,e
RETURN

// *** Update scale in VBX according to new LockIn scale
UpdateScale:
IF UseVbx = 0;
+   RETURN
CONTROL VBX g,SET,"ScaleMinValue",-LockScaleSpan
CONTROL VBX g,SET,"ScaleMaxValue",LockScaleSpan
CONTROL VBX g,SET,"TicStartValue",-LockScaleSpan
CONTROL VBX g,SET,"TicStopValue",LockScaleSpan
CONTROL VBX g,SET,"TicDeltaValue",LockScaleDelta
RETURN

// **** Update VBX needle position according to signal
UpdateNeedle:
GOSUB LockGetSignal

UpdateNeedle1:
//if LockSignal = LockCurSignal;RETURN
LockCurSignal = LockSignal
IF LockNeedleTau<=0.0001;
+   NeedleValue = LockCurSignal * LockScaleMult;
+   GOTO UN1
ndval = (LockCurSignal * LockScaleMult) - NeedleValue
u1 = abs(ndval) / LockScaleSpan
IF u1>0.01;
+   u1=(dtn/LockNeedleTau) / u1;
+   IF u1<5;
+       ndval = ndval * (1-exp(-u1))  // slow needle reaction

NeedleValue = NeedleValue+ndval
IF NeedleValue>LockScaleSpan;
+   NeedleValue = LockScaleSpan
IF NeedleValue<-LockScaleSpan;
+   NeedleValue=-LockScaleSpan

UN1:
IF UseVbx = 0;
+   RETURN
CONTROL VBX g,SET,"NeedleValue",NeedleValue
RETURN

// *** update needle and signal using LockCurSignal
UpdateNeedleSignal:
GOSUB UpdateNeedle1
LockSignal$ = LockCurSignal * LockSignalMult
RETURN

// *** Change sensitivity of LockIn
LockSensDown:
LockSetScale = LockCurScale + SensitivityMinus
GOSUB LockSetScale
RETURN

LockSensUp:
LockSetScale = LockCurScale - SensitivityPlus
GOSUB LockSetScale
RETURN

StepperSetup:
GOSUB SaveStepperPars
StepperPortD = StepperPort
LockPortD = LockPort
LockSensitivityD = LockSensitivity
LockNeedleTauD = LockNeedleTau
StepperDivD = StepperDiv
StepperLowD = StepperLow
StepperHighD = StepperHigh
StepperAccelD = StepperAccel
StepperDecelD = StepperDecel
StepperWaitD = StepperWait
StepperStepD = StepperStep*1000
DIALOG 0,0,0,0,"Stepper Motor & Lock-In Setup:"

x = 5
y = 5
h = 29

STATIC x,y+6,150,h-6,"Divider  K = "
EDIT x+150,y,65,h,StepperDivD
STATIC x+220,y+6,220,h-6,"(4, 1...255)"
y = y+h+3

STATIC x,y+6,150,h-6,"Start speed = "
EDIT x+150,y,65,h,StepperLowD
STATIC x+220,y+6,220,h-6,"Hz (600, 57...65000/K)"
y = y+h+3

STATIC x,y+6,150,h-6,"Max speed = "
EDIT x+150,y,65,h,StepperHighD
STATIC x+220,y+6,220,h-6,"Hz (4400, 57...65000/K)"
y = y+h+3

STATIC x,y+6,150,h-6,"Acceleration = "
EDIT x+150,y,65,h,StepperAccelD
STATIC x+220,y+6,220,h-6,"steps (20, 1...255)"
y = y+h+3

STATIC x,y+6,150,h-6,"Deceleration = "
EDIT x+150,y,65,h,StepperDecelD
STATIC x+220,y+6,220,h-6,"steps (10, 1...255)"
y = y+h+3

STATIC x,y+6,150,h-6,"Low power wait = "
EDIT x+150,y,65,h,StepperWaitD
STATIC x+220,y+6,220,h-6,"sec, (0.3, .01...2.5)"
y = y+h+3

STATIC x,y+6,150,h-6,"Stepper step = "
EDIT x+150,y,100,h,StepperStepD
STATIC x+255,y+6,100,h-6,"fsec (1/3) "
y = y+h+3

STATIC x,y+6,150,h-6,"LockIn Sens.= "
EDIT x+150,y,100,h,LockSensitivityD
STATIC x+255,y+6,100,h-6,"udA/V"
y = y+h+3

STATIC x,y+6,150,h-6,"Needle Tau = "
EDIT x+150,y,65,h,LockNeedleTauD
STATIC x+220,y+6,220,h-6,"ms (250 is OK)"
y = y+h+3

BUTTON x,y,100,h,"SET",SetMotorDialog
BUTTON x+200,y,100,h,"Cancel",CancelMotorDialog

END

CancelMotorDialog:
return

SetMotorDialog:
LockNeedleTau = LockNeedleTauD
StepperPort = StepperPortD
LockPort = LockPortD
LockSensitivity = LockSensitivityD
StepperDiv = StepperDivD
StepperLow = StepperLowD
StepperHigh = StepperHighD
StepperAccel = StepperAccelD
StepperDecel = StepperDecelD
StepperWait = StepperWaitD
StepperStep = StepperStepD / 1000
GOSUB SaveStepperPars
GOSUB StepperSetPars
RETURN

SaveStepperPars:
OPENP "PprobeMhzStepperPars.cfg" OUTPUT #1
IF result<>0;
+   PRINT "Cannot open PprobeMhzStepperPars.cfg for saving\n";
+   RETURN
PRINT #1,"Stepper Port = ",StepperPort,"\nLockIn Port = ",LockPort
PRINT #1,"\nK = ",StepperDiv,"\nlow = ",StepperLow,", high = ",StepperHigh
PRINT #1,"\nAccel = ",StepperAccel,", Decel = ",StepperDecel
PRINT #1,"\nWait = ",StepperWait
PRINT #1,"\nStep = ",StepperStep
PRINT #1,"\nLockIn Sensitivity = ",LockinSensitivity
PRINT #1,"\nLockin Needle Reaction Tau= ",LockNeedleTau
PRINT #1,"\n"
CLOSE 1
RETURN

LoadStepperPars:
OPENP "PprobeMhzStepperPars.cfg" INPUT #1
IF result<>0;
+   PRINT "Cannot open PprobeMhzStepperPars.cfg FOR reading\n";
+   RETURN
PRINT #1,?StepperPort,?LockPort
PRINT #1,?StepperDiv,?StepperLow,?StepperHigh
PRINT #1,?StepperAccel,?StepperDecel
PRINT #1,?StepperWait
PRINT #1,?StepperStep
PRINT #1,?LockinSensitivity
PRINT #1,?LockNeedleTau
CLOSE 1
RETURN


// *** If someone closes CONTROL window
ExitIt:
ExitIt = 1
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// Selecting COM ports
//
////////////////////////////////////////////////////////////////////////////////

SelectComPort:
GOSUB LoadStepperPars
StepperPortD = StepperPort
LockPortD = LockPort
DIALOG 0,0,0,0,"Stepper Motor& LockIn Communication Ports:"

x = 5
y = 5
h = 29

STATIC x,y+6,400,h-6,"Confirm COM port number connections"
y = y+h+3

BUTTON x,y,250,h*3+8,"Use last setting",CancelPortDialog

STATIC x+270,y+6,130,h-6,"Stepper port "
EDIT x+400,y,45,h,StepperPortD
y = y+h+3

STATIC x+270,y+6,130,h-6,"LockIn port "
EDIT x+400,y,45,h,LockPortD
y = y+h+5

BUTTON x+270,y,175,h, "Set new",SetPortDialog

END


CancelPortDialog:
RETURN

SetPortDialog:
StepperPort = StepperPortD
LockPort = LockPortD
GOSUB SaveStepperPars
RETURN


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Scanning                                                                   //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

Scan:

// Create scan dialog window
DIALOG 0,0,0,0,"Scan setup:"
x = 5
y = 5
h = 29

STATIC x,y,200,h,"X-axis scan param:"
y = y+h+3

STATIC x,y+6,70,h-6,"From"
STATIC x+75,y+6,60,h-6,"Step"
STATIC x+140,y+6,60,h-6,"Time"
y = y+h+3

FOR i = 1,ScanFs
    EDIT x,y,70,h,ScanF(i)
    EDIT x+75,y,60,h,ScanS(i)
    EDIT x+140,y,60,h,ScanT(i)
    y = y+h+3
NEXT

EDIT x,y,70,h,ScanTo
STATIC x+75,y+6,130,h-6,"<-Stop here"
y = y+h+3

CHECKBOX x,y,290,h,"Use X-template instead from:",UseTemplate
EDIT x+295,y,60,h,xTemplate
y = y+h+3

STATIC x,y+6,300,h-6,"Scan title/comment:"
y = y+h+1

EDIT x,y,620,h,ScanComment$
y = y+h+7

BUTTON x,y,340,h,"Acquire Data",DialogScanButton
BUTTON x+350,y,150,h,"Info",DialogInfoButton
BUTTON x+520,y,100,h,"Cancel",DialogCancelButton
x = x+250
y = 5

STATIC x,y,125,h,"Acquisition:"
y = y+h+3

STATIC x,y+6,160,h-6,"deltaA signal:";
STATIC x+200,y+6,165,h-6,"Instrument signal";
y = y+h+3

STATIC x,y+6,100,h-6,"Spectrum = "
EDIT x+105,y,60,h,ScanSpecDA

STATIC x+200,y+6,100,h-6,"Spectrum = "
EDIT x+200+105,y,60,h,ScanSpecInstr
y = y+h+3

STATIC x,y+6,90,h-6,"Divide"
LIST x+75,y,95,h*5,"None|X1*X2|X1*X1|X2*X2",DAdiv

STATIC x+200,y+6,90,h-6,"Divide"
LIST x+200+75,y,95,h*5,"None|X1*X2|X1*X1|X2*X2",InstrDiv
y = y+h+5

CHECKBOX x,y,300,h,"Normalize both to <Divide>",SpecNorm
y = y+h+20

STATIC x,y+6,240,h-6,"Average Background = "
EDIT x+215,y,60,h,AccuBack
STATIC x+280,y+6,40,h-6,"sec"
STATIC x,y+h,320,h-6,"(Set to 0 to omit bkg subtraction)"
y = y+h+h+6

STATIC x+180,y+6,120,h-1,"Save X1 into "
EDIT x+200+105,y,60,h,ScanSpecX1
y = y+h+3

STATIC x+180,y+6,120,h-1,"Save X2 into "
EDIT x+200+105,y,60,h,ScanSpecX2

END

////////////////////////////////////////////////////////////////////////////////
//
// sub DialogCancelButton
//     @unsure
//
////////////////////////////////////////////////////////////////////////////////

DialogCancelButton:
GOSUB LoadScanPars
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// sub DialogScanButton
//     @unsure
//
////////////////////////////////////////////////////////////////////////////////

DialogScanButton:
GOSUB SaveScanPars
GOSUB MakeScanX

// The user can enter bogus scan parameters, so check them before continuing.
IF len<0;
+   GOTO Scan;
IF len>10000;
+   MESSAGEBOX "Scan parameter error","Spectrum will have >10000 points, cannot do!",0;
+   GOTO Scan
IF len<4;
+   MESSAGEBOX "Scan parameter error","Spectrum will have less than 4 points, cannot do!",0;
+   GOTO Scan
IF ScanSpecDA<1;
+   MESSAGEBOX "Scan parameter error","dA Spectrum # out of range!",0;
+   GOTO Scan
IF ScanSpecDA>Amount;
+   MESSAGEBOX "Scan parameter error","dA Spectrum # out of range!",0;
+   GOTO Scan
IF ScanSpecInstr<0;
+   MESSAGEBOX "Scan parameter error","Intrument Spectrum # out of range!",0;
+   GOTO Scan
IF ScanSpecInstr>AMOUNT;
+   MESSAGEBOX "Scan parameter error","Intrument Spectrum # out of range!",0;
+   GOTO Scan
IF ScanSpecX1>Amount;
+   ScanSpecX1 = 0
IF ScanSpecX1<1;
+   ScanSpecX1 = 0
IF ScanSpecX2>Amount;
+   ScanSpecX2 = 0
IF ScanSpecX2<1;
+   ScanSpecX2 = 0

// Initialize the spectra that will hold the signal and the instrument function.
spec1 = ScanSpecDA;
len1 = 0
len1 = len
SETX spec1,AcqX
spec2 = ScanSpecInstr
SPECTRA spec2 = spec1
IF ScanSpecX1>0;
+   spec3 = ScanSpecX1;
+   SPECTRA spec3 = spec1
IF ScanSpecX2>0;
+   spec4 = ScanSpecX2;
+   SPECTRA spec4 = spec1

PRINT "\nAccumulating into ",spec1," and ",spec2,", channels = ",len1

// Disable the widgets in the control window.
EnableControl = 0
GOSUB EnableControl

// Send the delay line to the first position of the scan.
xpos = Specx1(1)
DelayNewPos = xpos
DelayNewPos$ = xpos
GOSUB DelayGo
PRINT "\nMoving to starting position ",DelayNewPos

// "AccuBack" is the time to accumulate the background as set by the user.
// If the user enters zero or less, then no background corrections will
// be made.
IF AccuBack<=0;
+   AccuT = 0;
+   AcqSb = 0;
+   Acq1b = 0;
+   Acq2b = 0;
+   Acq3b = 0;
+   PRINT "\nNo Background selected";
+   GOTO SKIPBACK

// @todo: Wait for the delay line to reach its destination before collecting
//        the background.

print "\nClose Shutter and wait for LIA to settle..."
Shutter = 0
GOSUB ShutterOpen
ShutterButton$ = "Shutter Closed"

tw = clock() + 3000  // wait 3 seconds: note - set time RC to 0.3 seconds

waitb1:
if clock()<tw;
+   IF ButtonStop = 0;
+   GOTO waitb1
if ButtonStop>0;
+   RETURN

// Measure background with closed shutter.
print "\nMeasuring background for ",AccuBack," seconds..."
AccuT = AccuBack
GOSUB Accumulate
AcqSb = AcqS
Acq1b = Acq1
Acq2b = Acq2
Acq3b = Acq3
print "\done, background = ",AcqSb,", ",Acq1,", ",Acq2,", ",Acq3

SKIPBACK:
PRINT "\nOpen shutter and wait 3 seconds"
Shutter = 1
GOSUB ShutterOpen
ShutterButton$ = "Shutter Open"
tw = clock() + 3000  // wait at least 3 seconds!

SpecNormDA = 1  // normalize
SpecNormInstr = 1
AverX1 = 0
AverX2 = 0
chan = 1

// Send the delay line to its next position.
newchan:
xpos = Specx1(chan)
if chan>1;
+   DelayNewPos = xpos;
+   DelayNewPos$ = xpos;
+   GOSUB DelayGo
print "\nChannel ",chan," at ",xpos," ps..."

// @todo: Make sure that you can stop the delay line somewhere in here.
wait1:
IF clock()<tw;
+   IF ButtonStop = 0;
+       GOTO wait1
GOSUB StepperFlush
GOSUB StepperMoving
GOSUB DelayGet
DelayCurPos$ = -DelayPos
if Moving>0;
+   tw = clock() + 20;
+   GOTO wait1

// Collect the current data point.
AccuT = AcqT(chan)
print "averaging"
GOSUB Accumulate
// Subtract the background.
AcqS = AcqS - AcqSb
Acq1 = Acq1 - Acq1b
Acq2 = Acq2 - Acq2b
Acq3 = Acq3 - Acq3b
print "\n   [",m,"pts] ",AcqS,", ",Acq1,", ",Acq2,", ",Acq3
// @unsure
InstrDivK = 1
if InstrDiv = 2;
+   InstrDivK = Acq1 * Acq2
if InstrDiv = 3;
+   InstrDivK = Acq1 * Acq1
if InstrDiv = 4;
+   InstrDivK = Acq2 * Acq2
InstrDivK = abs(InstrDivK)
if InstrDivK<1e-10;
+   InstrDivK = 1
DAdivK = 1
if DAdiv = 2;
+   DAdivK = Acq1 * Acq2
if DAdiv = 3;
+   DAdivK = Acq1 * Acq1
if DAdiv = 4;
+   DAdivK = Acq2 * Acq2
DAdivK = abs(DAdivK)
if DAdivK<1e-10;
+   DAdivK = 1

// @unsure
if chan = 1;
+   IF SpecNorm>0;
+       SpecNormDA = DAdivK;
+       SpecNormInstr = InstrDivK

// Store the collected data.
Spec1(chan) = AcqS
Spec2(chan)= Acq3 / InstrDivK * SpecNormInstr
if ScanSpecX1>0;
+   spec3(chan)=Acq1
if ScanSpecX2>0;
+   spec4(chan)=Acq2
AverX1 = AverX1 + Acq1
AverX2 = AverX2 + Acq2
REFRESH

// Check whether we're at the end of the scan.
chan = chan + 1
IF chan<=len1;
+   IF ButtonStop = 0;
+       GOTO newchan
chan = chan - 1  // last channel!
AverX1 = AverX1 / chan
AverX2 = AverX2 / chan
IF chan<len1;
+   len1 = chan;
+   len2 = chan
EnableControl = 1
GOSUB EnableControl

// Assemble the comments to store in the spectra, and then store them.
com$ = "\nLockIn sensitivity = ",LockSensitivity
IF UseTemplate>0;
+   com$ = com$,"\nX set by template",xTemplate,"\nChannel averaging = ",AcqT(1)," seconds"
IF UseTemplate = 0;
+   com$ = com$,"\nX Scanning break points:";
+   FOR i = 1,ScanFs;
+       com$ = com$,"\nX = ",ScanF(i)," Step = ",ScanS(i)," T = ",ScanT(i);
+   NEXT
com$ = com$,"\nBkgnd(",AccuBack,"s): ",AcqSb,",",Acq1b,",",Acq2b,",",Acq3b
com$ = com$,"\nAverages: X1 = ",AverX1,", X2 = ",AverX2
comment1$ = ScanComment$,"\nNormalized = ",DAdivK,com$
comment2$ = "INSTR: ",ScanComment$,"\nNormalized = ",InstrDivK,com$
IF ScanSpecX1>0;
+   comment3$ = "X1: ",ScanComment$,com$
IF ScanSpecX2>0;
+   comment3$ = "X2: ",ScanComment$,com$
REFRESH

// Open the shutter and go back to zero
Shutter = 1
GOSUB ShutterOpen
ShutterButton$ = "Shutter Open"
DelayNewPos = 0
DelayNewPos$ = 0  // @todo: maybe this is why the position sets itself to zero
GOSUB DelayGo
Moving1 = 1

RETURN

////////////////////////////////////////////////////////////////////////////////
//
// sub DialogInfoButton
//     Calculates and displays the time required to complete the scan.
//
// Args:
//     @unsure @missing_description
//
////////////////////////////////////////////////////////////////////////////////

DialogInfoButton:
GOSUB MakeScanX
msg$ = "There will be ",len," points\r\nAcquisition time about ",floor(TotalTime/6+.5)/10," + ",floor(TotalTime1/6+.5)/10," minutes"
MESSAGEBOX "Scan Info",msg$,0
GOTO Scan
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// sub Accumulate
//     Collect and average data for the specified period of time.
//
// Args:
//     AccuT (float): The time to accumulate each parameter
//     LockSlow @unsure
//     @unsure
//
// Returns:
//     AcqS (float): The averaged Q value from the LIA
//     Acq1 (float): The averaged X1 value from the LIA
//     Acq2 (float): The averaged X2 value from the LIA
//     Acq3 (float): The averaged X3 value from the LIA
//
////////////////////////////////////////////////////////////////////////////////

Accumulate:
AcqS = 0
Acq1 = 0
Acq2 = 0
Acq3 = 0

// @todo: this rounds down too much, should it round to the nearest integer?
m = floor(AccuT * 4)

// @unsure
// take every 250 ms m times (one read of 4 numbers takes 220 ms)
dtw_ls = 100
if LockSlow = 1;
+   dtw_ls = 250
tw = clock() + dtw_ls

// @unsure I think "m" is the number of milliseconds between readings
m = floor(AccuT * 1000 / dtw_ls)
if m<1;
+   m = 1
mm = 0

GOSUB LockFlushFast
send$ = "\n"
GOSUB LockSend
GOSUB LockFlush

ACC1:

ACCwait:
if clock()<tw;
+   IF ButtonStop = 0;
+       GOTO ACCwait

tw = clock() + dtw_ls
if LockSlow = 1;
+   GOSUB LockGetAll1
if LockSlow = 0;
+   GOSUB LockGetAll
LockCurSignal = LockSignal
Stat$ = "RD",mm,"/",m,":",LockSignal,",",LockX1,",",LockX2,",",LockX3," (",clock() + dtw_ls - tw,")"

// @unsure
if clock()>ts;
+   ts = clock()+dts;
+   LockSignal$ = LockCurSignal * LockSignalMult

GOSUB UpdateNeedle1
LockSignal$ = LockCurSignal*LockSignalMult
AcqS = AcqS + LockSignal
Acq1 = Acq1 + LockX1
Acq2 = Acq2 + LockX2
Acq3 = Acq3 + LockX3

// Proceed to the next accumulation increment if we're not done.
mm = mm + 1
if mm>=m;
+   GOTO ACC2
if ButtonStop>0;
+   GOTO ACC2
GOTO ACC1

// Compute the average.
ACC2:
AcqS = AcqS / m
Acq1 = Acq1 / m
Acq2 = Acq2 / m
Acq3 = Acq3 / m

RETURN

MakeScanX:
IF useTemplate = 0;
+   GOTO MSX0
Len = -1
if xTemplate<0;
+   MESSAGEBOX "Scan parameter error","X-Template Spectrum # out of range!",0;
+   RETURN
if xTemplate<0;
+   MESSAGEBOX "Scan parameter error","X-Template Spectrum # out of range!",0;
+   RETURN
spec0 = xTemplate
Len = len0
if Len<1;
+   RETURN
DIM AcqX(len),AcqT(len)
t = ScanT(1)
FOR i = 1,len0
    AcqX(i) = specx0(i)
    AcqT(i) = t
NEXT
TotalTime = len * t
TotalTime1 = AcqX(len) - AcqX(1)
RETURN

MSX0:
Sta = ScanF(1)
Ste = ScanS(1)
Len = 0
FOR i = 2,ScanFs
if ScanS(i)<=0;
+   GOTO MSX1
if ScanT(i)<=0;
+   GOTO MSX1
if ScanF(i)<Sta;
+   GOTO MSX1
len = len + (ScanF(i) - Sta) / Ste + 1
Sta = ScanF(i)
Ste = ScanS(i)
MSX1:
NEXT

IF ScanTo>Sta;
+   len = len + (ScanTo - Sta) / Ste + 1
IF len>10000;
+   RETURN
IF len<4;
+   RETURN
dim AcqX(len),AcqT(len)
x = ScanF(1)
t = ScanT(1)
s = ScanS(1)
k = 2
i = 1

MSX2:
IF k>ScanFs;
+   GOTO MSX3
IF ScanT(k)<=0;
+   k = k+1;
+   GOTO MSX2
IF ScanS(k)<=0;
+   k = k+1;
+   GOTO MSX2
IF x>=ScanF(k);
+   s = ScanS(k);
+   t = ScanT(k);
+   k = k+1;
+   GOTO MSX2
AcqX(i) = x
AcqT(i) = t
i = i + 1
x = x + s
IF i<len;
+   IF x<=ScanTo;
+       GOTO MSX2

MSX3:
IF x>ScanTo;
+   GOTO MSX4
IF i>len;
+   GOTO MSX4
AcqX(i) = x
AcqT(i) = t
x = x + s
i = i + 1
GOTO MSX3

MSX4:
len = i-1
DIM AcqX(len),AcqT(len)
TotalTime = 0
FOR i = 1,len
TotalTime = TotalTime + AcqT(i)
NEXT
TotalTime1 = AcqX(len) - AcqX(1)

RETURN

SaveScanPars:
OPENP "PprobeMhzScanPars.cfg" OUTPUT #1
IF result<>0;
+   PRINT "Cannot open PprobeMhzScanPars.cfg for saving\n";
+   RETURN
PRINT #1,"ScanTo = ",ScanTo
PRINT #1,"\nScanFs = ",ScanFs
PRINT #1,"\nDivs = ",DAdiv,",",InstrDiv
PRINT #1,"\nUseTemplate = ",UseTemplate,",",xTemplate
PRINT #1,"\nScanSpecs = ",ScanSpecDA,",",ScanSpecInstr
FOR i = 1,ScanFs
    PRINT #1,"\nScanF = ",ScanF(i),",",ScanS(i),",",ScanT(i)
NEXT
PRINT #1,"\nAccuBack = ",AccuBack,", Normalize = ",SpecNorm
PRINT #1,"\n",ScanComment$
PRINT #1,"\n"
CLOSE 1
RETURN

ScanPars:
RETURN

LoadScanPars:
OPENP "PprobeMhzScanPars.cfg" INPUT #1
IF result<>0;
+   PRINT "Cannot open PprobeMhzScanPars.cfg for loading\n";
+   RETURN
PRINT #1,?ScanTo,?ScanFs,?DAdiv,?InstrDiv,?UseTemplate,?xTemplate
PRINT #1,?ScanSpecDA,?ScanSpecInstr
FOR i = 1,ScanFs
    PRINT #1,?ScanF(i),?ScanS(i),?ScanT(i)
NEXT
PRINT #1,?AccuBack,?SpecNorm
PRINT #1,?ScanComment$
CLOSE 1
RETURN


////////////////////////////////////////////////////////////////////////////////
//
// @unsure Interactively control the stepper motor?
//
////////////////////////////////////////////////////////////////////////////////

u = 0
DelayNewPos = 0
GOSUB delayGo
PRINT ?x

again:
u = u+1
GOSUB DelayGo
GOSUB DelayGet
GOSUB StepperMoving
PRINT "\n",u,":",DelayPos,"  ",Moving
GOTO again

PRINT "\nGoto: ",?DelayNewPos
GOSUB DelayGo
GOSUB DelayGet
PRINT "{",DelayPos,"}"
GOSUB StepperMoving
PRINT "(",Moving,")"
GOSUB LockGetAll
PRINT "  S = ",LockSignal,",",x1,",",X2,",",x3
GOTO again
STOPP

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Lock-in amplifier subroutines                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// sub LockInit
//     Open a connection to the lock-in amplifier.

LockInit:
parity$ = "NONE"
flow$ = "DTRDSR"
OPENCOM LockPort,9600,8,1,parity$,flow$ AS #4
IF result<>0;
+   PRINT "\nconnection failed at 'opencom' level! press enter...",?x,"\n";
+   STOPP
PRINT "\nConnection to LIA opened."
PRINT "\nInitializing communication with LIA.\n"
PRINT "Flushing buffer...\n"
GOSUB LockFlush
PRINT "Sending request...\n"
send$ = "\n\n"
GOSUB LockSendR
PRINT "Flushing...\n"
GOSUB LockFlush
LockWait = 0
GOSUB LockSetWait
PRINT "Done\n\n"
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// sub LockSend
//     Send a command to the LIA.
//
// Args:
//     send$: The text to send to the LIA
//
////////////////////////////////////////////////////////////////////////////////

LockSend:
GOSUB LockFlushFast
IF debug>0;
+   PRINT "\nTo LockIn: [",send$,"]"
PRINT #4,send$,"\n"  // note: #4 is the handle to the LIA COM port
IF Log = 10;
+   PRINT #9,"\nSend$ = ",Send$
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// sub LockSendR
//     Send a command to the LIA and store the response.
//
// Args:
//     send$: The text to send to the LIA
//
// Returns:
//     LG$: The text received from the LIA
//
////////////////////////////////////////////////////////////////////////////////

LockSendR:
GOSUB LockSend
GOSUB LockGet
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// sub LockGet
//     Receives a single line from the LIA, stripping the CRLF from the end.
//
// Returns:
//     LG$: The text received from the LIA
//
////////////////////////////////////////////////////////////////////////////////

LockGet:
// build a buffer that is 200 characters long
LG$ = ""
FOR i=1,20
    LG$ = LG$,"          "
NEXT
k = 0
t = clock() + 250  // wait no more than 250 ms for each symbol

lockGetNextResponseChar:
f = filelen(4)  // note: 4 is the handle to the LIA COM port
IF f>0;
+   LOAD #4,unsigned1,a;
+   k = k + 1;
+   LG$(k) = a;
+   t = clock() + 250;
+   IF a<>13;
+       GOTO lockGetNextResponseChar
IF f<1;
+   IF clock()<t;
+       GOTO lockGetNextResponseChar
LG$(k + 1) = 0
IF LG$(k)=10;
+   LG$(k)=0
IF LG$(k-1)=13;
+   LG$(k-1)=0
IF debug>0;
+   PRINT "\nFrom LockIn: [",LG$,"]"
IF Log = 10;
+   PRINT #9," {",LG$,"}"
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// sub LockGetF
//     Get the frequency from the LIA.
//
// Returns:
//     LG$: The text received from the LIA
//
////////////////////////////////////////////////////////////////////////////////

LockGetF:
send$ = "F"
GOSUB LockSendR
LockF = LG$
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// sub LockGetSignal
//     Get the signal Q (quotient) from the LIA.
//
// Returns:
//     LG$: The text received from the LIA
//
////////////////////////////////////////////////////////////////////////////////

LockGetSignal:
send$ = "Q"
GOSUB LockSendR
LockSignal = LG$
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// sub LockSetWait
//     Set the time between characters sent by the LIA.
//
//     The LIA is able to wait a specific amount of time between characters sent
//     as part of a response. The time interval must be a multiple of 4ms, and
//     has a default value of 6*4ms = 24ms.
//
// Args:
//     LockWait (int): The number of 4ms intervals between characters in a
//                     response from the LIA
//
////////////////////////////////////////////////////////////////////////////////

LockSetWait:
send$ = "W",LockWait
GOSUB LockSend
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// sub LockFlush
//     Flush the receiving buffer of the LIA COM port.
//
////////////////////////////////////////////////////////////////////////////////

LockFlush:
t = clock() + 5  // wait no more than 5 ms for each symbol

LF1:
f = filelen(4)  // note: 4 is the handle of the LIA COM port
IF f>0;
+   LOAD #4,unsigned1,a;
+   t = clock()+5;
+   GOTO LF1
IF clock()<t;
+   GOTO LF1
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// sub LockFlush
//     @unsure @missing_description
//
////////////////////////////////////////////////////////////////////////////////

LockFlushFast:

LFF1:
f = filelen(4)
IF f>0;
+   LOAD #4,unsigned1,a;
+   GOTO LF1;
+   GOTO LFF1
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// sub LockFlushLong
//     Flush the receiving buffer of the LIA COM port using a longer wait
//     time between characters.
//
////////////////////////////////////////////////////////////////////////////////

LockFlushLong:
t = clock() + 20  // wait no more than 20 ms FOR each symbol

LFL1:
f = filelen(4)  // note: 4 is the handle of the LIA COM port
IF f>0;
+   LOAD #4,unsigned1,a;
+   t = clock() + 20;
+   GOTO LFL1
IF clock()<t;
+   GOTO LFL1
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// sub LockGetAll
//     Get all four signals (Q, X1, X2, X3) from the LIA.
//
// Returns:
//     LockSignal (float): The LIA signal Q
//     LockX1 (float): The voltage from LIA input X1
//     LockX2 (float): The voltage from LIA input X2
//     LockX3 (float): The voltage from LIA input X3
//
////////////////////////////////////////////////////////////////////////////////

LockGetAll:
LGAn = 0

LockGetAllagain:
LGAe = 0
send$ = "Q;X1;X2;X3"
GOSUB LockSendR
LockSignal = LG$
LGAe = LG$(0)  // @unsure
GOSUB LockGet
LockX1 = LG$
LGAe = LGAe*LG$(0)
GOSUB LockGet
LockX2 = LG$
LGAe = LGAe*LG$(0)
GOSUB LockGet
LockX3 = LG$
AGAe = LGAe*LG$(0)
IF LGAe>0;
+   RETURN
PRINT "\n#### LockIn response error, correcting ",LGAn
// error detected: did not get data! Repeat
IF Log = 10;
+   PRINT #9,"\n########### Error! Correcting ",LGAn," #############\n"
IF LGAn>5;
+   RETURN  // enough is enough!
LGAn = LGAn + 1
GOSUB LockFlush
send$ = "\n\n"
GOSUB LockSend
GOSUB LockFlushLong
GOTO LockGetAllagain
RETURN

// This appears to be a helper subroutine that gets the signals one at a time
LockGetAll1:
GOSUB LockGetSignal
send$ = "X1"
GOSUB LockSendR
LockX1 = LG$
send$ = "X2"
GOSUB LockSendR
LockX2 = LG$
send$ = "X3"
GOSUB LockSendR
LockX3 = LG$
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// sub LockGetScale
//     Get the LIA scale (sensitivity).
//
//     The sensitivity of the LIA follows the pattern 1,2,5 to some power of
//     10 followed by an associated unit (nV, uV, mV). The sensitivity is
//     reported as an integer "n" that ranges from 1 to 24 that cycles through
//     the various combinations of the span (1, 2, or 5), and the multiplier
//     (the power of 10).
//
// Returns:
//     LockScaleSpan (int): The significant digits of the sensitivity
//     LockScaleMult (float): The multiplier for the sensitivity
//     LockSignalUnit$ (string): The unit associated with the sensitivity
//     LockSignalMult (float): The multiplier for display purposes
//     LockScaleDelta (int): @unsure @missing_description
//
////////////////////////////////////////////////////////////////////////////////

LockGetScale:
GOSUB LockFlush
send$ = "G"
GOSUB LockSendR
lg = lg$
IF lg = 0;
+   RETURN
LockScale = LG$
i = LockScale
x1 = 10
x2 = 1e9
x3 = 1e9
x$ = "nV"

IF i=1;
+   x1 = 10;
+   x2 = 1e9;
+   X3 = 1e9;
+   x$ = "nV";
+   GOTO LGS1  // 10nV
IF i=2;
+   x1 = 2;
+   x2 = 1e8;
+   X3 = 1e9;
+   x$ = "nV";
+   GOTO LGS1  // 20nV
IF i=3;
+   x1 = 5;
+   x2 = 1e8;
+   X3 = 1e9;
+   x$ = "nV";
+   GOTO LGS1  // 50nV
IF i=4;
+   x1 = 10;
+   x2 = 1e8;
+   X3 = 1e9;
+   x$ = "nV";
+   GOTO LGS1  // 100nV
IF i=5;
+   x1 = 2;
+   x2 = 1e7;
+   X3 = 1e9;
+   x$ = "nV";
+   GOTO LGS1  // 200nV
IF i=6;
+   x1 = 5;
+   x2 = 1e7;
+   X3 = 1e9;
+   x$ = "nV";
+   GOTO LGS1  // 500nV
IF i=7;
+   x1 = 10;
+   x2 = 1e7;
+   X3 = 1e6;
+   x$ = "uV";
+   GOTO LGS1  // 1uV
IF i=8;
+   x1 = 2;
+   x2 = 1e6;
+   X3 = 1e6;
+   x$ = "uV";
+   GOTO LGS1  // 2uV
IF i=9;
+   x1 = 5;
+   x2 = 1e6;
+   X3 = 1e6;
+   x$ = "uV";
+   GOTO LGS1  // 5uV
IF i=10;
+   x1 = 10;
+   x2 = 1e6;
+   X3 = 1e6;
+   x$ = "uV";
+   GOTO LGS1  // 10uV
IF i=11;
+   x1 = 2;
+   x2 = 1e5;
+   X3 = 1e6;
+   x$ = "uV";
+   GOTO LGS1  // 20uV
IF i=12;
+   x1 = 5;
+   x2 = 1e5;
+   X3 = 1e6;
+   x$ = "uV";
+   GOTO LGS1  // 50uV
IF i=13;
+   x1 = 10;
+   x2 = 1e5;
+   X3 = 1e6;
+   x$ = "uV";
+   GOTO LGS1  // 100uV
IF i=14;
+   x1 = 2;
+   x2 = 1e4;
+   X3 = 1e6;
+   x$ = "uV";
+   GOTO LGS1  // 200uV
IF i=15;
+   x1 = 5;
+   x2 = 1e4;
+   X3 = 1e6;
+   x$ = "uV";
+   GOTO LGS1  // 500uV
IF i=16;
+   x1 = 10;
+   x2 = 1e4;
+   X3 = 1e3;
+   x$ = "mV";
+   GOTO LGS1  // 1mV
IF i=17;
+   x1 = 2;
+   x2 = 1e3;
+   X3 = 1e3;
+   x$ = "mV";
+   GOTO LGS1  // 2mV
IF i=18;
+   x1 = 5;
+   x2 = 1e3;
+   X3 = 1e3;
+   x$ = "mV";
+   GOTO LGS1  // 5mV
IF i=19;
+   x1 = 10;
+   x2 = 1e3;
+   X3 = 1e3;
+   x$ = "mV";
+   GOTO LGS1  // 10mV
IF i=20;
+   x1 = 2;
+   x2 = 1e2;
+   X3 = 1e3;
+   x$ = "mV";
+   GOTO LGS1  // 20mV
IF i=21;
+   x1 = 5;
+   x2 = 1e2;
+   X3 = 1e3;
+   x$ = "mV";
+   GOTO LGS1  // 50mV
IF i=22;
+   x1 = 10;
+   x2 = 1e2;
+   X3 = 1e3;
+   x$ = "mV";
+   GOTO LGS1  // 100mV
IF i=23;
+   x1 = 2;
+   x2 = 1e1;
+   X3 = 1e3;
+   x$ = "mV";
+   GOTO LGS1  // 200mV
IF i=24;
+   x1 = 5;
+   x2 = 1e1;
+   X3 = 1e3;
+   x$ = "mV";
+   GOTO LGS1  // 500mV
LGS1:
LockScaleSpan = x1
LockScaleMult = x2
LockSignalUnit$ = x$
LockSignalMult = X3
IF LockScaleSpan = 10;
+   LockScaleDelta = 2
IF LockScaleSpan = 2;
+   LockScaleDelta = 0.5
IF LockScaleSpan = 5;
+   LockScaleDelta = 1
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// sub LockSetScale
//     Set the sensitivity of the LIA.
//
// Args:
//     n (int): The index of the desired sensitivity (see the LIA manual)
//
////////////////////////////////////////////////////////////////////////////////

LockSetScale:
IF LockSetScale<4;
+   LockSetScale = 4
IF LockSetScale>24;
+   LockSetScale = 24
send$ = "G",LockSetScale
GOSUB LockSend
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// Delay line controls in time units
//
////////////////////////////////////////////////////////////////////////////////

// ****** Shutter open or close (Shutter = 1 or 0)
ShutterOpen:
send$ = "A",8*Shutter
GOSUB SendStepper
RETURN

// ******* Stop delay line
DelayStop:
GOSUB StepperStop
RETURN

// ******* Check if delay line is Moving, (Moving = 1 - moving, Moving = 0 - stopped)
DelayMoving:
GOSUB StepperMoving
RETURN

// *******Go to DelaynewPos in picoseconds
DelayGo:
GOSUB StepperStop
StepperNewPos = -floor(DelayNewPos / StepperStep)
GOSUB StepperGo
RETURN

// ******* Get current delay position in picoseconds (to nearest femtosecond)
DelayGet:
GOSUB StepperGetPos
DelayPos = floor(StepperPos * StepperStep * 1000 + 0.5) / 1000
RETURN

// ****** Set current position of delay line to be DelayOrigin in ps (without moving)
DelaySetOrigin:
StepperOrigin = DelayOrigin / StepperStep
GOSUB StepperSetOrigin
RETURN


////////////////////////////////////////////////////////////////////////////////
//
// Delay line controls in native units
//
////////////////////////////////////////////////////////////////////////////////

// *************** Initialize stepper driver. Must do at least once
StepperInit:
parity$ = "NONE"
flow$ = "DTRDSR"
OPENCOM StepperPort,9600,8,1,parity$,flow$ AS #3
IF result<>0;
+   PRINT "\nconnection failed at 'opencom' level! press enter...",?x,"\n";
+   STOPP
PRINT "\nConnection to stepper opened."
PRINT "\nInitializing communication with stepper.\n"
send$ = " "
GOSUB SendStepper  // initialize connection
// get 4 lines of answer
PRINT "...\n"
GOSUB GetStepper
PRINT "...\n"
GOSUB GetStepper
PRINT "...\n"
GOSUB GetStepper
PRINT "...\n"
GOSUB GetStepper
PRINT "...\n"
GOSUB StepperSetPars
PRINT "Done\n\n"
RETURN

// ************* Initialize scanning parameters: must do if changing scan speeds
// ************ Initialize function will call this as well
StepperSetPars:
send$ = "l1"
GOSUB SendStepperR  // set limits to normally ground
send$ = "E",floor(StepperWait * 100)
GOSUB SendStepperR  // set power-low delay in 10 ms intervals
StepperDiv = floor(StepperDiv)
IF StepperDiv<1;
+   StepperDiv = 1
IF StepperDiv>1255;
+   StepperDiv = 255
StepperDiv = floor(StepperDiv)
send$ = "D",StepperDiv
GOSUB SendStepperR  // set divider
IF StepperLow*StepperDiv>65500;
+   StepperLow = 65500 / StepperDiv
IF StepperLow*StepperDiv<56;
+   StepperLow = (56 / StepperDiv) + 1
StepperLow = floor(StepperLow)
send$ = "I",StepperLow*StepperDiv
GOSUB SendStepperR  // set lbeginning stepper speed
IF StepperHigh*StepperDiv>65500;
+   StepperHigh = 65500 / StepperDiv
IF StepperHigh*StepperDiv<56;
+   StepperHigh = (56 / StepperDiv) + 1
StepperHigh = floor(StepperHigh)
send$ = "V",StepperHigh*StepperDiv
GOSUB SendStepperR  // set high speed
IF StepperAccel<1;
+   StepperAccel = 0
IF StepperAccel>255;
+   StepperAccel = 255
IF StepperDecel<1;
+   StepperDecel = 0
IF StepperDecel>255;
+   StepperDecel = 255
send$ = "K",StepperAccel," ",StepperDecel
GOSUB SendStepperR  // set high speed
send$ = "X"
GOSUB SendStepperR
RETURN

// **************** Send string SEND$ to a stepper controller and receive answer into SR$
SendStepperR:
GOSUB SendStepper
GOSUB GetStepper
RETURN

// *************** Send string SEND$ to a stepper, does not wait for answer (just for echo)
SendStepper:
IF debug>0;
+   PRINT "\nTo stepper: [",send$,"]"
FOR i = 1,send$(0)
  char = send$(i)
  GOSUB SendStepperChar
NEXT
IF send$(1)<>32;
+   PRINT #3,"\n"
RETURN

// ************** Sends one CHAR to stepper and receives echo of char back (waits 30 ms for response or skips)
SendStepperChar:
PRINT #3,%char
t = clock() + 300  // wait 30 ms for response, if none - just quit

waitStepperChar:
IF clock()<t;
+   IF filelen(3)<1;
+       GOTO waitStepperChar
IF filelen(3)>0;
+   LOAD #3,unsigned1,a;¨
+   IF debug>1;
+       PRINT "[",%a,"|",a,"]"
RETURN

// ************** receives one line from Stepper controller into SR$, strips CRLF at end and replaces 0 chars with spaces
GetStepper:
SR$ = "                                                                                                                                                                                                           "; //buffer
k = 0
t = clock() + 300  // wait no more than 100 ms for each symbol

SR1:
f = filelen(3)
IF f>0;
+   LOAD #3,unsigned1,a;
+   k = k + 1;
+   GOSUB checka;
+   SR$(k) = a;
+   t = clock() + 100;
+   IF a<>10;
+       GOTO SR1
IF f<1;
+   IF clock()<t;
+   GOTO SR1
SR$(k + 1) = 0
IF SR$(k)=10;
+   SR$(k) = 0
IF SR$(k - 1)=13;
+   SR$(k - 1) = 0
IF debug>0;
+   PRINT "\nFrom Stepper: [",SR$,"]"
IF log = 10;
+   PRINT #9 "Received: ",SR$,"\n"
IF SR$(1)=90;
+   SR$(1) = 0
RETURN

// **** function for routine above (replace 0 with space), controller sends 0 char before each number!
checka:
IF a=0;
+   a = 32
RETURN

// ********* Flush input buffer from controller, just in case there is junk
StepperFlush:
t = clock() + 5  // wait no more than 5 ms for each symbol
SF1:
f = filelen(3)
IF f>0;
+   LOAD #3,unsigned1,a;
+   GOTO SF1
IF clock()<t;
+   GOTO SF1
RETURN

// ********** Go to StepperNewPos in native coordinates
StepperGo:
GOSUB StepperFlush
send$ = "R",floor(StepperNewPos)
GOSUB SendStepperR
GOSUB GetStepper
RETURN

// ********* Gets current position in native coordinates
StepperGetPos:
GOSUB StepperFlush
send$ = "Z"
GOSUB SendStepperR
StepperPos = SR$
RETURN

// ****** This sets the current position to be StepperOrigin in absolute coordinates
StepperSetOrigin:
send$ = "O",floor(StepperOrigin)
GOSUB SendStepperR
RETURN

// ********* Check if delay line is moving (Moving<>0 for moving, and =0 when stopped)
StepperMoving:
send$ = "^"
GOSUB SendStepperR
Moving = SR$
RETURN

// *********** Stop delay line motion (with deceleration), waits for it to stop but not more than for 1 second
StepperStop:
send$ = "@"
GOSUB SendStepperR
SST = clock() + 1000

SS1:
GOSUB StepperMoving
IF Moving = 0;
+   RETURN
IF clock()<SST;
+   GOTO SS1
RETURN

////////////////////////////////////////////////////////////////////////////////
//
// Lock-in amplifier interactive commands (for debugging)
//
////////////////////////////////////////////////////////////////////////////////

TTYlockin:
PRINT "\n\nCommand line mode for LockIn\nPress ESC to exit\n"
localecho = 1

again33:
a = inkey();
IF a = 27;
+   RETURN
IF a>0;
+   PRINT #4,%a;
+   IF localecho<>0;
+       GOSUB printa
IF filelen(4)>0;
+   LOAD #4,unsigned1,a;¨
+   GOSUB printa
GOTO again33

PRINTA:
IF A = 13;
+   PRINT "\N";
+   RETURN
IF A<32;
+   RETURN
PRINT %A
RETURN

